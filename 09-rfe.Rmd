---
title: "09. Feature selection"
author: "Al Xin"
date: "1/12/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = F)
```

## Overview

Though RFE seems to not significantly drop the accuracy of the model (from
`08-rf.Rmd`), it is extremely time intensive. For workflow, it may be easier to
run RFE with a single model before testing the resulting variables on a variety
of model types.

Recursive feature elimination through caret will be implemented using the random
forest functions. The resulting top 10 variables will be used in model-building.
The `"rfe"` objects generated by caret will be saved in the directory `rfe/obj/`.
The variables chosen will be saved in the directory `rfe/var/`. Finally, the data
frames created from RFE will be saved in `rfe/df/`

The organization of `rfe/obj/` and `rfe/df/` will mirror that of `desc/`. The 
organization of `rfe/var/` will not have subfolders for descriptor type; instead, 
each descriptor type will be saved as a list in RDS form. E.g., the variables for 
all Mordred descriptors will be saved as the RDS file `mordred.RDS`, which will
be a list with each element having the name of the data source.

```{r dir}
desc_src <- c("cdk", "mordred", "ochem", "padel")

if (!dir.exists("rfe")) {
  dir.create("rfe")
  dir.create("rfe/obj")
  dir.create("rfe/var")
  dir.create("rfe/df")
  dir_save <- lapply(paste0("rfe/obj/", desc_src), dir.create)
  dir_save <- lapply(paste0("rfe/df/", desc_src), dir.create)
}
```
## Dependencies

```{r dependencies}
library(caret)
library(qsarr)
# library(parallel)
# library(doParallel)
```

## Running recursive feature elimination

Using `caret::rfeControl()`, the recursive feature elimination will be composed of 10 repeats of 10-fold cross-validation. 

The data is read into a list of lists. In order to prevent an error from discarding progress, each element of the list will be saved independently. 

<!-- RFE also requires heavy computing resources, so parallel processing will be implemented with `parallel` and `doParallel`.  -->

```{r rfe}
# read data
desc_list <- lapply(
  paste0("preprocess/", desc_src), 
  function(x) {
    read_desc_list(list.files(x, full.names = T), quiet = T)
  }
) %>%
  setNames(desc_src)

data_name <- names(desc_list[[1]])

rfe_ctrl <- rfeControl(
  functions = rfFuncs,
  method = "repeatedcv",
  repeats = 10, 
  number = 10
)

desc_name <- paste0(
  unlist(lapply(desc_src, rep, length(data_name))), 
  "/", rep(data_name, length(desc_list))
)
desc_list <- unlist(desc_list, recursive = F)
names(desc_list) <- desc_name

# # Parallel processing setup
# num_core <- detectCores()
# # Subtracting 2 from total cores prevents R from using all system resources
# if (num_core > 2) num_core <- num_core - 2
# 
# cl <- makeCluster(num_core)
# registerDoParallel(cl)

set.seed(20210113)
desc_rfe <- lapply(
  desc_name, 
  function(x) {
    rfe_obj <- rfe(
      form = dG ~ . - guest,
      data = desc_list[[x]], 
      rfeControl = rfe_ctrl
    )
    saveRDS(rfe_obj, paste0("rfe/obj/", x, ".RDS"))
  }
)
# stopCluster(cl)
```

## Retrieving variables

The top 12 variables over all the sets will be used. This is one less than the 
number of observations in the smallest data set (`cdk/ri_gamma`). Additionally, 
a dozen variables is likely a small enough number of predictors such that each 
individual component can be manually analyzed and explained, while also 
containing enough information to make predictions, based off of RFE from step
09 (random forest proof of concept.)

In future model building, both the entire set of predictors and the selected 
variables will be used and model performance will be compared. 

```{r}
rfe_list <- lapply(
  paste0("rfe/obj/", desc_src), 
  function(x) {
    lapply(
      list.files(x, full.names = T), 
      readRDS
    )
  }
)

rfe_var <- lapply(
  rfe_list, 
  function(x) {
    lapply(
      x, 
      function(y) {
        # Though dplyr::top_n works the same as arrange and slice, using the 
        # two separate functions has the advantage that the relative order
        # of the variables in the vector corresponds to the relative importance
        y$variables %>%
          group_by(var) %>%
          summarize(importance = mean(Overall), .groups = "drop") %>%
          arrange(desc(importance)) %>%
          slice(1:12) %>%
          .$var
      }
    )
  }
) %>%
  setNames(desc_src) %>%
  lapply(setNames, nm = data_name)

rfe_save <- lapply(
  desc_src, 
  function(x) saveRDS(rfe_var[[x]], paste0("rfe/var/", x, ".RDS"))
)

```

## Creating data frames with selected variables

In addition to the top 16 variables from the previous step, the variable `"dG"`, which is the response, should also be retained. Though the column `"guest"` is useful for identification of the target molecule, at the tuning stage it is not important to keep it in the data.

```{r}
# Reading from the files to verify that saving the variables worked
rfe_var <- lapply(
  paste0("rfe/var/", desc_src, ".RDS"), 
  readRDS
) %>%
  setNames(desc_src)

# Reading desc_list again as a list of 4 (not 36) to match the setup of rfe_var
desc_list <- lapply(
  paste0("preprocess/", desc_src), 
  function(x) {
    read_desc_list(list.files(x, full.names = T), quiet = T)
  }
) %>%
  setNames(desc_src)

rfe_df <- lapply(
  desc_src, 
  function(x) {
    lapply(
      data_name, 
      function(y) {
        desc_list[[x]][[y]] %>% 
          select(all_of(c("dG", rfe_var[[x]][[y]])))
      }
    )
  }
) %>%
  unlist(recursive = F) %>%
  setNames(desc_name)

rfe_save <- lapply(
  desc_name, 
  function(x) saveRDS(rfe_df[[x]], paste0("rfe/df/", x, ".RDS"))
)
```

