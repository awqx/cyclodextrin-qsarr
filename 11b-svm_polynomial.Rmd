---
title: "11. SVM"
author: "Al Xin"
date: "1/5/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = F)
library(pacman)
p_load(
  caret,
  data.table,
  doParallel, 
  dplyr, 
  ggplot2, 
  parallel, 
  qsarr,
  stringr, 
  tidyr
)
theme_set(theme_bw())
knitr::opts_chunk$set(echo = TRUE, eval = F)
```

## Overview

Models built on all predictor variables will be saved in `model/svm_polynomial/all_var/`. 
Models trained on variables selected from RFE in 09 will be saved in `model/svm_polynomial/rfe_var`. 

```{r directories}
desc_src <- c("cdk", "mordred", "ochem", "padel")

if (!dir.exists("model")) dir.create("model")
if (!dir.exists("model/svm_polynomial")) {
  dir.create("model/svm_polynomial")
  dir.create("model/svm_polynomial/all_var")
  dir.create("model/svm_polynomial/rfe_var")
  dir_create_result <- sapply(paste0("model/svm_polynomial/all_var/", desc_src), dir.create)
  dir_create_result <- sapply(paste0("model/svm_polynomial/rfe_var/", desc_src), dir.create)
}
```

### General outline for model building

## All variables

For creating models with all the variables, the descriptors are read as separate 
lists. This makes it clearer that different possible tuning parameters are used
based on the number of descriptors available. 

## Polynomial SVM

As mentioned in building the linear SVM, `qsarr` handles each polynomial kernel through a different `tune` call.

An SVM with a polynomial kernel draws a polynomial boundary to explain the data. It has high variance and lower bias compared to a linear kernel. It is susceptible to making large errors with higher degree polynomials, especially for new data outside of the applicability domain. This will become clear with analysis of the results of a polynomial kernel SVM. 

### All Variables

```{r, eval = F}
load("data/all_var.Rdata")
num_core <- max(1, detectCores() - 1)
cl <- makeCluster(num_core)
registerDoParallel(cl)
cl_lib <- clusterEvalQ(cl, library("qsarr"))

clusterSetRNGStream(cl = cl, 20210807)
cdk_all <- parLapply(
  cl = cl,
  cdk_list,
  tune,
  method = "svm_polynomial",
  resp = "dG",
  ignore_col = "guest",
  nfold = 10,
  nrep = 10,
  degree = c(1:5),
  coef0 = c(-10, -1, 0, 1, 10),
  cost = c(0.5, 1, 3, 10, 20)
)

cdk_all_save <- lapply(
  data_name,
  function(x) {
    saveRDS(cdk_all[[x]], paste0("model/svm_polynomial/all_var/cdk/", x, ".RDS"))
  }
)

clusterSetRNGStream(cl = cl, 20210807)
padel_all <- parLapply(
  cl = cl,
  padel_list, 
  tune, 
  method = "svm_polynomial", 
  resp = "dG",
  ignore_col = "guest",
  nfold = 10,
  nrep = 10,
  degree = c(1:5),
  coef0 = c(-10, -1, 0, 1, 10),
  cost = c(0.5, 1, 3, 10, 20)
)

padel_all_save <- lapply(
  data_name, 
  function(x) {
    saveRDS(padel_all[[x]], paste0("model/svm_polynomial/all_var/padel/", x, ".RDS"))
  }
)

clusterSetRNGStream(cl = cl, 20210807)
mordred_all <- parLapply(
  cl = cl,
  mordred_list, 
  tune, 
  method = "svm_polynomial", 
  resp = "dG",
  ignore_col = "guest",
  nfold = 10,
  nrep = 10,
  degree = c(1:5),
  coef0 = c(-10, -1, 0, 1, 10),
  cost = c(0.5, 1, 3, 10, 20)
)

mordred_all_save <- lapply(
  data_name, 
  function(x) {
    saveRDS(mordred_all[[x]], paste0("model/svm_polynomial/all_var/mordred/", x, ".RDS"))
  }
)

clusterSetRNGStream(cl = cl, 20210807)
ochem_all <- parLapply(
  cl = cl,
  ochem_list, 
  tune, 
  method = "svm_polynomial", 
  resp = "dG",
  ignore_col = "guest",
  nfold = 10,
  nrep = 10,
  degree = c(1:5),
  coef0 = c(-10, -1, 0, 1, 10),
  cost = c(0.5, 1, 3, 10, 20)
)

ochem_all_save <- lapply(
  data_name, 
  function(x) {
    saveRDS(ochem_all[[x]], paste0("model/svm_polynomial/all_var/ochem/", x, ".RDS"))
  }
)
stopCluster(cl = cl)
```

#### RFE

```{r}
load("data/rfe.Rdata")
# Parallel processing setup
num_core <- max(1, detectCores() - 1)
cl <- makeCluster(num_core)
registerDoParallel(cl)
cl_lib <- clusterEvalQ(cl, library("qsarr"))

clusterSetRNGStream(cl = cl, 20210722)
cdk_rfe <- parLapply(
  cl = cl,
  cdk_list_rfe,
  tune, 
  method = "svm_polynomial", 
  resp = "dG",
  ignore_col = "guest",
  nfold = 10,
  nrep = 10,
  degree = c(1:5),
  coef0 = c(-10, -1, 0, 1, 10),
  cost = c(0.5, 1, 3, 10, 20)
)

cdk_rfe_save <- lapply(
  data_name, 
  function(x) {
    saveRDS(cdk_rfe[[x]], paste0("model/svm_polynomial/rfe_var/cdk/", x, ".RDS"))
  }
)

clusterSetRNGStream(cl = cl, 20210722)
padel_rfe <- parLapply(
  cl = cl,
  padel_list_rfe,
  tune, 
  method = "svm_polynomial", 
  resp = "dG",
  ignore_col = "guest",
  nfold = 10,
  nrep = 10,
  degree = c(1:5),
  coef0 = c(-10, -1, 0, 1, 10),
  cost = c(0.5, 1, 3, 10, 20)
)

padel_rfe_save <- lapply(
  data_name, 
  function(x) {
    saveRDS(padel_rfe[[x]], paste0("model/svm_polynomial/rfe_var/padel/", x, ".RDS"))
  }
)

clusterSetRNGStream(cl = cl, 20210722)
mordred_rfe <- parLapply(
  cl = cl,
  mordred_list_rfe,
  tune, 
  method = "svm_polynomial", 
  resp = "dG",
  ignore_col = "guest",
  nfold = 10,
  nrep = 10,
  degree = c(1:5),
  coef0 = c(-10, -1, 0, 1, 10),
  cost = c(0.5, 1, 3, 10, 20)
)

mordred_rfe_save <- lapply(
  data_name, 
  function(x) {
    saveRDS(mordred_rfe[[x]], paste0("model/svm_polynomial/rfe_var/mordred/", x, ".RDS"))
  }
)

clusterSetRNGStream(cl = cl, 20210722)
ochem_rfe <- parLapply(
  cl = cl,
  ochem_list_rfe,
  tune, 
  method = "svm_polynomial", 
  resp = "dG",
  ignore_col = "guest",
  nfold = 10,
  nrep = 10,
  degree = c(1:5),
  coef0 = c(-10, -1, 0, 1, 10),
  cost = c(0.5, 1, 3, 10, 20)
)

ochem_rfe_save <- lapply(
  data_name, 
  function(x) {
    saveRDS(ochem_rfe[[x]], paste0("model/svm_polynomial/rfe_var/ochem/", x, ".RDS"))
  }
)
stopCluster(cl = cl)
```

## External validation

```{r}
desc_name <- c("cdk", "mordred", "ochem", "padel")
data_name <- str_remove(list.files("desc/cdk"), "\\.RDS$")
```

First, the data generated from Step 07 is read into a list.

```{r}
ev_list <- lapply(
  paste0("extval_pp/", desc_name), 
  function(x) {
    lapply(
      list.files(x, full.names = T), 
      readRDS
    ) %>%
      setNames(nm = data_name)
  }
) %>%
  setNames(nm = desc_name)
```

External validation follows the same steps as described in `10-rf.Rmd`. 

### All Variables

The results on external validation for polynomial SVMs can be predicted. Performance on all molecules and performance on the applicability domain can be contrasted.

```{r}
svm_polynomial_allvar <- lapply(
  paste0("model/svm_polynomial/all_var/", desc_name), 
  function(x) {
    lapply(
      list.files(x, full.names = T), 
      readRDS
    ) %>%
      setNames(nm = data_name)
  }
) %>%
  setNames(nm = desc_name)
```

```{r}
ev_allvar <- lapply(
  desc_name, 
  function(x) {
    tune_sublist <- svm_polynomial_allvar[[x]]
    ev_sublist <- ev_list[[x]]
    lapply(
      data_name, 
      function(y) {
        pred <- predict(tune_sublist[[y]], ev_sublist[[y]])
        data.frame(
          guest = ev_sublist[[y]]$guest, 
          in_ad = ev_sublist[[y]]$in_ad,
          obs = ev_sublist[[y]]$dG, 
          pred = pred
        )
      }
    ) %>%
      setNames(data_name)
  }
) %>% 
  setNames(desc_name)

# All results, regardless of applicability domain
ev_allvar_result <- lapply(
  ev_allvar, 
  function(x) {
    lapply(
      x, 
      defaultSummary
    ) %>%
      setNames(data_name)
  }
) %>%
  setNames(desc_name)

# Accuracy only on applicability domain
ev_allvar_result_ad <- lapply(
  ev_allvar, 
  function(x) {
    lapply(
      x, 
      function(y) {
        y <- y[y$in_ad, ]
        defaultSummary(y)
      }
    ) %>%
      setNames(data_name)
  }
) %>% 
  setNames(desc_name)
```

#### RFE

The same procedure for prediction is carried out with models only built on variables selected with RFE. 

```{r}
svm_polynomial_rfe <- lapply(
  paste0("model/svm_polynomial/rfe_var/", desc_name), 
  function(x) {
    lapply(
      list.files(x, full.names = T), 
      readRDS
    ) %>%
      setNames(nm = data_name)
  }
) %>%
  setNames(nm = desc_name)

ev_rfe <- lapply(
  desc_name, 
  function(x) {
    tune_sublist <- svm_polynomial_rfe[[x]]
    ev_sublist <- ev_list[[x]]
    lapply(
      data_name, 
      function(y) {
        pred <- predict(tune_sublist[[y]], ev_sublist[[y]])
        data.frame(
          guest = ev_sublist[[y]]$guest, 
          in_ad = ev_sublist[[y]]$in_ad,
          obs = ev_sublist[[y]]$dG, 
          pred = pred
        )
      }
    ) %>%
      setNames(data_name)
  }
) %>% 
  setNames(desc_name)

# All results, regardless of applicability domain
ev_rfe_result <- lapply(
  ev_rfe, 
  function(x) {
    lapply(
      x, 
      defaultSummary
    ) %>%
      setNames(data_name)
  }
) %>%
  setNames(desc_name)

# Accuracy only on applicability domain
ev_rfe_result_ad <- lapply(
  ev_rfe, 
  function(x) {
    lapply(
      x, 
      function(y) {
        y <- y[y$in_ad, ]
        defaultSummary(y)
      }
    ) %>%
      setNames(data_name)
  }
) %>% 
  setNames(desc_name)
```


## Results

### Model-building process

The results are first read from the lists generated from tuning and saved in the
directory `result/trn/`.

```{r}
svm_polynomial_allvar_df <- rbindlist(
  lapply(
    desc_name, 
    function(x) {
      desc_list <- svm_polynomial_allvar[[x]]
      rbindlist(
        lapply(
          data_name, 
          function(y) {
            mutate(desc_list[[y]]$result_summary, data_src = y)
          }
        )
      ) %>%
        mutate(desc_src = x)
    }
  )
) 

svm_polynomial_rfe_df <- rbindlist(
  lapply(
    desc_name, 
    function(x) {
      desc_list <- svm_polynomial_rfe[[x]]
      rbindlist(
        lapply(
          data_name, 
          function(y) {
            mutate(desc_list[[y]]$result_summary, data_src = y)
          }
        )
      ) %>%
        mutate(desc_src = x)
    }
  )
) 

saveRDS(svm_polynomial_allvar_df, "result/trn/all_var/svm_polynomial.RDS")
saveRDS(svm_polynomial_rfe_df, "result/trn/rfe_var/svm_polynomial.RDS")
```

```{r, eval = T, echo = F}
svm_polynomial_allvar_df <- readRDS("result/trn/all_var/svm_polynomial.RDS")
svm_polynomial_rfe_df <- readRDS("result/trn/rfe_var/svm_polynomial.RDS")

ggplot(svm_polynomial_allvar_df, aes(x = data_src, y = fold_avg, fill = desc_src)) + 
  geom_col(position = "dodge") + 
  facet_grid(summary_stat ~ ., scales = "free") + 
  labs(
    x = "Data source", 
    y = "Average value over repeated 10-fold CV", 
    title = "Results for SVM polynomial models on all variables", 
    fill = "Chemical descriptor"
  )

# Due to high maximums, replace data w/ 10
svm_allvar_temp <- mutate(
  svm_polynomial_allvar_df, 
  fold_avg = pmin(fold_avg, 12)
)

svm_rfe_temp <- mutate(
  svm_polynomial_rfe_df, 
  fold_avg = pmin(fold_avg, 12)
)

ggplot(svm_allvar_temp, aes(x = data_src, y = fold_avg, fill = desc_src)) + 
  geom_col(position = "dodge") + 
  facet_grid(summary_stat ~ ., scales = "free") + 
  labs(
    x = "Data source", 
    y = "Average value over repeated 10-fold CV", 
    title = "Results for SVM polynomial models on all variables", 
    fill = "Chemical descriptor"
  )

ggplot(svm_rfe_temp, aes(x = data_src, y = fold_avg, fill = desc_src)) + 
  geom_col(position = "dodge") + 
  facet_grid(summary_stat ~ ., scales = "free") + 
  labs(
    x = "Data source", 
    y = "Average value over repeated 10-fold CV", 
    title = "Results for random forest models on RFE-selected variables", 
    fill = "Chemical descriptor"
  )
```
### External validation 

```{r}
ev_allvar_df <- data.table::rbindlist(
  lapply(
    unlist(ev_allvar_result, recursive = F), 
    function(x) {
      data.frame(as.list(x))
    }
  )
) %>%
  data.frame(
    desc_src = unlist(lapply(desc_name, rep, length(data_name))), 
    data_src = rep(data_name, length(desc_name))
  ) %>%
  pivot_longer(RMSE:MAE, names_to = "summary_stat")

ev_allvar_ad_df <- data.table::rbindlist(
  lapply(
    unlist(ev_allvar_result_ad, recursive = F), 
    function(x) {
      data.frame(as.list(x))
    }
  )
) %>%
  data.frame(
    desc_src = unlist(lapply(desc_name, rep, length(data_name))), 
    data_src = rep(data_name, length(desc_name))
  ) %>%
  pivot_longer(RMSE:MAE, names_to = "summary_stat")

ev_rfe_df <- data.table::rbindlist(
  lapply(
    unlist(ev_rfe_result, recursive = F), 
    function(x) {
      data.frame(as.list(x))
    }
  )
) %>%
  data.frame(
    desc_src = unlist(lapply(desc_name, rep, length(data_name))), 
    data_src = rep(data_name, length(desc_name))
  ) %>%
  pivot_longer(RMSE:MAE, names_to = "summary_stat")

ev_allvar_ad_df <- data.table::rbindlist(
  lapply(
    unlist(ev_allvar_result_ad, recursive = F), 
    function(x) {
      data.frame(as.list(x))
    }
  )
) %>%
  data.frame(
    desc_src = unlist(lapply(desc_name, rep, length(data_name))), 
    data_src = rep(data_name, length(desc_name))
  ) %>%
  pivot_longer(RMSE:MAE, names_to = "summary_stat")

ev_rfe_ad_df <- data.table::rbindlist(
  lapply(
    unlist(ev_rfe_result_ad, recursive = F), 
    function(x) {
      data.frame(as.list(x))
    }
  )
) %>%
  data.frame(
    desc_src = unlist(lapply(desc_name, rep, length(data_name))), 
    data_src = rep(data_name, length(desc_name))
  ) %>%
  pivot_longer(RMSE:MAE, names_to = "summary_stat")

ev_allvar_temp <- mutate(
  ev_allvar_df, 
  value = pmin(value, 12)
)

ev_allvar_ad_temp <- mutate(
  ev_allvar_ad_df, 
  value = pmin(value, 12)
)

ev_rfe_temp <- mutate(
  ev_rfe_df, 
  value = pmin(value, 12)
)

ev_rfe_ad_temp <- mutate(
  ev_rfe_ad_df, 
  value = pmin(value, 12)
)

ggplot(ev_allvar_df, aes(x = data_src, y = value, fill = desc_src)) + 
  geom_col(position = "dodge") + 
  facet_grid(summary_stat ~ ., scales = "free")

ggplot(ev_allvar_ad_temp, aes(x = data_src, y = value, fill = desc_src)) + 
  geom_col(position = "dodge") + 
  facet_grid(summary_stat ~ ., scales = "free")

ggplot(ev_rfe_df, aes(x = data_src, y = value, fill = desc_src)) + 
  geom_col(position = "dodge") + 
  facet_grid(summary_stat ~ ., scales = "free")

ggplot(ev_rfe_ad_temp, aes(x = data_src, y = value, fill = desc_src)) + 
  geom_col(position = "dodge") + 
  facet_grid(summary_stat ~ ., scales = "free")
# svm_polynomial_tst <- svm_polynomial_allvar[[1]]
# ev_tst <- ev_list[[1]]
# pred_tst <- lapply(
#   names(svm_polynomial_tst), 
#   function(x) {
#     # svm_polynomial_model <- svm_polynomial_tst[[x]]$model
#     # predict(svm_polynomial_model, ev_tst[[x]])
#     predict(svm_polynomial_tst[[x]], ev_tst[[x]])
#   }
# )
```

```{r}
print.tune <- function(tune_obj) {
  cat(
    "Model type: ", class(tune_obj$model), "\n\n",
    "Tuned parameters: ", "\n",
    sapply(
      names(tune_obj$param),
      function(x) {
        paste0("\t", x, ": ", tune_obj$param[[x]], "\n")
      }
    ), "\n",
    "Number of predictors: ", length(tune_obj$pred_name), "\n",
    "Predictors (first 10): ",
    tune_obj$pred_name[1:(min(10, length(tune_obj$pred_name)))],
    "\n", "\n",
    "Model performance: ", "\n"
  )
  print(tune_obj$result_summary)
}

predict.tune <- function(tune_obj, ...) {
  # if (length(class(tune_obj$model)) > 1) {
  #   class(tune_obj$model) <-
  #     class(tune_obj$model)[length(class(tune_obj$model))]
  # }
  # best_model <- tune_obj$model
  # UseMethod("predict", best_model)
  predict(tune_obj$model, ...)
}
```

